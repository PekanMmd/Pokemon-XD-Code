//  This Source Code Form is subject to the terms of the Mozilla Public
//  License, v. 2.0. If a copy of the MPL was not distributed with this
//  file, You can obtain one at https://mozilla.org/MPL/2.0/. 

/// enum LZ77 
///     A namespace for LZ77-related functionality.
/// ## (top-level-namespaces)
public 
enum LZ77 
{
    enum Format 
    {
        case zlib 
        case ios
    }
}

// modular redundancy check (similar to PNG.CRC32)
extension LZ77 
{
    enum MRC32 
    {
        // software.intel.com/content/www/us/en/develop/articles/fast-computation-of-adler32-checksums
        // link also says to use simd vectorization, but that just seems to slow 
        // things down (probably because llvm is already autovectorizing it)
        static 
        func update(_ checksum:(single:UInt32, double:UInt32), 
            from start:UnsafePointer<UInt8>, count:Int) 
            -> (single:UInt32, double:UInt32)
        {
            let (q, r):(Int, Int) = count.quotientAndRemainder(dividingBy: 5552)
            var (single, double):(UInt32, UInt32) = checksum
            for i:Int in 0 ..< q 
            {
                for j:Int in 5552 * i ..< 5552 * (i + 1)
                {
                    single &+= .init(start[j])
                    double &+= single 
                }
                single %= 65521
                double %= 65521
            }
            for j:Int in 5552 * q ..< 5552 * q + r
            {
                single &+= .init(start[j])
                double &+= single 
            }
            return (single % 65521, double % 65521)
        }
    }
}

// huffman tables
extension LZ77 
{
    struct Huffman<Symbol> where Symbol:Comparable 
    {
        let symbols:[Symbol],
            levels:[Range<Int>]
        // these are size parameters generated by the structural validator. 
        // we store them here as proof of tree validity, so that the 
        // constructor for the huffman Decoder type can just read it from here 
        fileprivate
        let size:(n:Int, z:Int)
        
        private 
        init(symbols:[Symbol], levels:[Range<Int>], size:(n:Int, z:Int))
        {
            self.symbols = symbols
            self.levels  = levels
            self.size    = size
        }
    }
}
extension LZ77.Huffman where Symbol:BinaryInteger
{
    // empty or single-element tree  
    init(stub:Symbol?)
    {
        if let stub:Symbol = stub
        {
            self.symbols    = [stub]
            self.levels     = [0 ..< 1] + repeatElement(1 ..< 1, count: 14)
        }
        else 
        {
            self.symbols    = []
            self.levels     = [0 ..< 0] + repeatElement(0 ..< 0, count: 14)
        }
        self.size = (n: 256, z: 256)
    }
    
    // non validating initializer, crashes on invalid input 
    init(symbols:[Symbol], levels:[Range<Int>])
    {
        guard let size:(n:Int, z:Int) = Self.size(levels)
        else 
        {
            fatalError("invalid huffman table leaf list")
        }
        self.init(symbols: symbols, levels: levels, size: size)
    } 
    
    // validate leaf counts
    private static
    func size(_ levels:[Range<Int>]) -> (n:Int, z:Int)?
    {
        // count the interior nodes
        var interior:Int = 1 // count the root
        for leaves:Range<Int> in levels[0 ..< 8]
        {
            // every interior node on the level above generates two new nodes.
            // some of the new nodes are leaf nodes, the rest are interior nodes.
            interior    = 2 * interior - leaves.count
        }
        
        // the number of interior nodes remaining is the number of child trees
        let n:Int       = 256 - interior
        var z:Int       = 256 // n
        // finish validating the tree
        for (i, leaves):(Int, Range<Int>) in levels[8 ..< 15].enumerated()
        {
            z       += leaves.count << (6 - i)
            interior = 2 * interior - leaves.count
        }
        
        guard interior == 0
        else
        {
            return nil
        }
        
        return (n, z)
    }
    
    // handles 0-symbol and 1-symbol edge cases
    static
    func validate<Symbols, Lengths>(symbols:Symbols, normalizing lengths:Lengths) 
        -> Self?
        where   Symbols:Collection,        Lengths:Collection, 
                Symbols.Element == Symbol, Lengths.Element == Int
    {
        var first:Symbol?
        for (symbol, length):(Symbol, Int) in zip(symbols, lengths) where length > 0
        {
            if first == nil, length == 1 
            {
                first = symbol
            }
            else 
            {
                // only way to get here is if we have already encountered a symbol, 
                // or we have encountered a symbol with a codelength greater than 1, 
                // either of which means there are at least two symbols, so we can 
                // use the normal constructor.
                return Self.validate(symbols: symbols, lengths: lengths)
            }
        }
        // zero- and single-symbol cases
        return .init(stub: first)
    }
    
    static
    func validate<Symbols, Lengths>(symbols:Symbols, lengths:Lengths) -> Self?
        where   Symbols:Collection,        Lengths:Collection, 
                Symbols.Element == Symbol, Lengths.Element == Int
    {
        var counts:[Int] = .init(repeating: 0, count: 16)
        for length:Int in lengths
        {
            counts[length] += 1
        }
        let ranges:[Range<Int>] = .init(unsafeUninitializedCapacity: 15)
        {
            var base:Int = 0
            for (i, count):(Int, Int) in counts.dropFirst().enumerated()
            {
                $0[i] = base ..< base + count
                base += count
            }
            $1 = 15
        }
        
        guard let size:(n:Int, z:Int) = Self.size(ranges)
        else
        {
            return nil
        }
        
        let packed:[Symbol] = .init(unsafeUninitializedCapacity: ranges[14].upperBound)
        {
            for (symbol, length):(Symbol, Int) in zip(symbols, lengths) where length > 0
            {
                $0[ranges[length - 1].upperBound - counts[length]] = symbol
                counts[length] -= 1
            }
            $1 = ranges[14].upperBound
        }
        return .init(symbols: packed, levels: ranges, size: size)
    }
    
    func table<Pattern>(initializing destination:UnsafeMutablePointer<Pattern>) 
        where Pattern:LZ77.Symbol.Pattern, Pattern.Symbol == Symbol
    {
        var current:UnsafeMutablePointer<Pattern> = destination
        for (l, level):(Int, Range<Int>) in zip(1 ... 8, self.levels.prefix(8))
        {
            let clones:Int  = 256 >> l
            for symbol:Symbol in self.symbols[level]
            {
                let pattern:Pattern = .init(symbol, length: l)
                current.initialize(repeating: pattern, count: clones)
                current += clones 
            }
        }
        current = destination + 256
        for (l, level):(Int, Range<Int>) in zip(9 ... 15, self.levels.dropFirst(8))
        {
            let clones:Int  = 32768 >> l
            for symbol:Symbol in self.symbols[level]
            {
                let pattern:Pattern = .init(symbol, length: l)
                current.initialize(repeating: pattern, count: clones)
                current += clones
            }
        }
    }
}
extension LZ77
{
    enum FixedHuffman 
    {
    }
}
extension LZ77.FixedHuffman 
{
    static 
    let runliteral:LZ77.Huffman<UInt16> = .init(
        symbols: [256 ... 279, 0 ... 143, 280 ... 287, 144 ... 255].flatMap{ $0 },
        levels:
            .init(repeating:   0 ..<   0, count: 6) + // L1 ... L6
            [0 ..< 24, 24 ..< 176, 176 ..< 288]     + // L7, L8, L9
            .init(repeating: 288 ..< 288, count: 6)   // L10 ... L15
        )
    static 
    let distance:LZ77.Huffman<UInt8> = .init(
        symbols: .init(0 ... 31),
        levels:
            .init(repeating:  0 ..<  0, count:  4)  +
            [0 ..< 32]                              +
            .init(repeating: 32 ..< 32, count: 10)
        )
}
extension LZ77 
{
    enum Decades 
    {
        static 
        subscript(run run:Int) -> UInt8 
        {
            assert(3 ...   258 ~= run)
            return Self.table[run - 3]
        }
        static 
        subscript(distance distance:Int) -> UInt8 
        {
            assert(1 ... 32768 ~= distance)
            return distance <= 256 ? 
                Self.table[256 | (distance - 1)     ] : 
                Self.table[512 | (distance - 1) >> 7]
        }

        private static 
        let table:[UInt8] =
        [
            // length codes
            // 257 ... 264
             1,  2,  3,  4,  5,  6,  7,  8, 
            // 265 ... 268
             9,  9, 10, 10, 11, 11, 12, 12, 
            // 269 ... 272
            13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 
            // 273 ... 274
            17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 
            // 275 ... 276
            19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 
            // 277 ... 280
            21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 
            22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 
            23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
            24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
            // 281
            25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
            25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
            // 282
            26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 
            26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 
            // 283
            27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 
            27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 
            // 284 ... 285 (there is an overlapping composite for length = 258)
            28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 
            28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 
            // distance codes 
            // 0 ... 3
             0,  1,  2,  3,  
            // 4 ... 5
             4,  4,  5,  5, 
            // 6 ... 7
             6,  6,  6,  6,  7,  7,  7,  7, 
            // 8 ... 9
             8,  8,  8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 
            // 10 ... 11
            10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 
            11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 
            
            12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
            12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 
            
            13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 
            13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 
            
            14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 
            14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
            14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 
            14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 
            
            15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
            15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
            15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
            15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
            // ~~~ 7-bit fold ~~~
             0,  0, // padding, to simplify index calculation
            16, 17,
            18, 18, 19, 19, 
            20, 20, 20, 20, 21, 21, 21, 21, 
            22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 
            
            24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
            25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
            
            26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 
            26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 
            
            27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 
            27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 
            
            28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
            28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 
            28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 
            28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 
            
            29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 
            29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
            29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 
            29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
        ]
    }
    enum Composites 
    {
        // these are only used by the deflator in deflate.swift,, the inflator 
        // reads these values from the Semistatic table, for memory locality
        static 
        subscript(run decade:UInt8) -> (extra:UInt16, base:UInt16) 
        {
            return Self.table[.init(decade)]
        }
        static 
        subscript(distance decade:UInt8) -> (extra:UInt16, base:UInt16) 
        {
            return Self.table[.init(32 | decade)]
        }
        
        fileprivate static 
        let table:[(extra:UInt16, base:UInt16)] = 
        [
            // front-padding, which allows us to use a bitmask to 
            // get the decade index
            (0,   0),
            
            // run decades
            (0,   3),
            (0,   4),
            (0,   5),
            (0,   6),
            (0,   7),
            
            (0,   8),
            (0,   9),
            (0,  10),
            (1,  11),
            (1,  13),
            
            (1,  15),
            (1,  17),
            (2,  19),
            (2,  23),
            (2,  27),
            
            (2,  31),
            (3,  35),
            (3,  43),
            (3,  51),
            (3,  59),
            
            (4,  67),
            (4,  83),
            (4,  99),
            (4, 115),
            (5, 131),
            
            (5, 163),
            (5, 195),
            (5, 227),
            (0, 258),
            
            // padding values, because out-of-bounds symbols occur
            // in fixed huffman trees, and may be erroneously decoded 
            // if the decoder goes beyond the end-of-stream (which it is 
            // temporarily allowed to do, for performance)
            (0,   0),
            (0,   0),
            
            // distance decades 
            ( 0,     1),
            ( 0,     2),
            ( 0,     3),
            ( 0,     4),
            ( 1,     5),
            
            ( 1,     7),
            ( 2,     9),
            ( 2,    13),
            ( 3,    17),
            ( 3,    25),
            
            ( 4,    33),
            ( 4,    49),
            ( 5,    65),
            ( 5,    97),
            ( 6,   129),
            
            ( 6,   193),
            ( 7,   257),
            ( 7,   385),
            ( 8,   513),
            ( 8,   769),
            
            ( 9,  1025),
            ( 9,  1537),
            (10,  2049),
            (10,  3073),
            (11,  4097),
            
            (11,  6145),
            (12,  8193),
            (12, 12289),
            (13, 16385),
            (13, 24577),
            
            // padding values, because out-of-bounds symbols occur
            // in fixed huffman trees, and may be erroneously decoded 
            // if the decoder goes beyond the end-of-stream (which it is 
            // temporarily allowed to do, for performance)
            ( 0,     0),
            ( 0,     0),
        ]
    }
    enum Reversed 
    {
        // these are only used by the deflator in deflate.swift,, the inflator 
        // reads these values from the Semistatic table, for memory locality
        static 
        subscript<T>(byte:T) -> T where T:BinaryInteger 
        {
            self.table.withUnsafeBufferPointer
            {
                .init($0[.init(byte)])
            }
        }
        
        fileprivate static 
        let table:[UInt8] =
        [
            0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 
            0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
            0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8, 
            0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
            0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4, 
            0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
            0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 
            0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
            0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 
            0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
            0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA, 
            0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
            0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 
            0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
            0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE, 
            0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
            0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1, 
            0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
            0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9, 
            0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
            0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5, 
            0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
            0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED, 
            0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
            0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 
            0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
            0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB, 
            0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
            0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 
            0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
            0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF, 
            0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
        ]
    }
}
extension LZ77.Inflator 
{
    struct Semistatic 
    {
        private 
        typealias Composite = (extra:UInt16, base:UInt16)
        
        private 
        let storage:ManagedBuffer<Void, UInt8>,
            fence:(runliteral:Int, distance:Int),
            offset:Int
            //runliteral:(fence:Int, fold:Int),
            //distance:(offset:Int, fence:Int, fold:Int)
        //               stack
        //    0 ┌───────────────────────┐ : Buffer pointer 
        //      ├───────────────────────┤ : Run-literal fence
        //      ├───────────────────────┤ : Distance fence
        //      ├───────────────────────┤ : Distance table offset
        //   32 └───────────────────────┘
        //                heap
        //    0 ┌───────────────────────┐
        //      │                       │
        //      │  byte reversal table  │ : 256 * UInt8
        //      │                       │
        //  256 ├───────────────────────┤
        //      │   Run decade table    │ : 32 * (UInt16, UInt16) 
        //  384 ├───────────────────────┤
        //      │ Distance decade table │ : 32 * (UInt16, UInt16) 
        //  512 ├───────────────────────┤ 
        //      │                       │
        //      │                       │
        //      │                       │
        //      │                       │
        //      │                       │
        //      │                       │
        //      │   Run-literal table   │
        //      │        (1-8 KB)       │
        //      │                       │
        //      │                       │
        //      │                       │
        //      │                       │
        //      │                       │
        //      │                       │
        //      │                       │
        //      ├───────────────────────┤
        //      │                       │
        //      │                       │
        //      │                       │
        //      │                       │
        //      │                       │
        //      │                       │
        //      │     Distance table    │
        //      │        (1-4 KB)       │
        //      │                       │
        //      │                       │
        //      │                       │
        //      │                       │
        //      │                       │
        //      │                       │
        //      │                       │
        //      └───────────────────────┘
    }
}
extension LZ77.Inflator.Semistatic 
{        
    init(runliteral:LZ77.Huffman<UInt16>, distance:LZ77.Huffman<UInt8>) 
    {
        let start:Int   = 256    + MemoryLayout<Composite>.stride * 64
        let offset:Int  = start  + MemoryLayout<LZ77.Symbol.RunLiteral>.stride * runliteral.size.z 
        let size:Int    = offset + MemoryLayout<LZ77.Symbol.Distance  >.stride *   distance.size.z
        self.storage = .create(minimumCapacity: size){ _ in () }
        self.storage.withUnsafeMutablePointerToElements 
        {
            (base:UnsafeMutablePointer<UInt8>) in 
            
            // write byte reversal table 
            (base         ).initialize(from: LZ77.Reversed.table, count: 256)
            // write decade tables 
            (base +    256).withMemoryRebound(to: Composite.self, capacity: 64) 
            {
                $0.initialize(from: LZ77.Composites.table, count: 64)
            }
            // write huffman tables 
            (base +  start).withMemoryRebound(to: LZ77.Symbol.RunLiteral.self, 
                capacity: runliteral.size.z)
            {
                runliteral.table(initializing: $0)
            }
            (base + offset).withMemoryRebound(to: LZ77.Symbol.Distance.self, 
                capacity: distance.size.z)
            {
                distance.table(initializing: $0)
            }
        }
        
        self.fence  = (runliteral: runliteral.size.n, distance: distance.size.n)
        self.offset = offset
    }
    
    // bits in lower half of the uint16
    private
    func reverse(_ byte:UInt16) -> Int
    {
        // fastest bit twiddle in the west,, now that i measured it
        // now i know why everyone at apple asks this same coding interview question
        self.storage.withUnsafeMutablePointerToElements
        {
            .init($0[.init(byte)])
        }
    }
    private
    func index(_ codeword:UInt16, fence:Int) -> Int
    {
        let first:Int = self.reverse(codeword & 0x00ff)
        return first <  fence ?
               first :
            (( first &- fence &+ 2 ) << 8 | self.reverse(codeword >> 8)) >> 1
    }
    
    subscript(codeword:UInt16, as _:LZ77.Symbol.RunLiteral.Type) -> LZ77.Symbol.RunLiteral 
    {
        self.storage.withUnsafeMutablePointerToElements 
        {
            let raw:UnsafeRawPointer = .init($0)
            // should get constant-folded
            let start:Int  = 256    + 64 * MemoryLayout<Composite>.stride
            let offset:Int = start &+ MemoryLayout<LZ77.Symbol.RunLiteral>.stride &* 
                self.index(codeword, fence: self.fence.runliteral)
            return raw.load(fromByteOffset: offset, as: LZ77.Symbol.RunLiteral.self)
        }
    }
    subscript(codeword:UInt16, as _:LZ77.Symbol.Distance.Type) -> LZ77.Symbol.Distance 
    {
        self.storage.withUnsafeMutablePointerToElements 
        {
            let raw:UnsafeRawPointer = .init($0)
            let offset:Int = self.offset &+ MemoryLayout<LZ77.Symbol.Distance>.stride &*
                self.index(codeword, fence: self.fence.distance)
            return raw.load(fromByteOffset: offset, as: LZ77.Symbol.Distance.self)
        }
    }
    
    func composite(decade runliteral:LZ77.Symbol.RunLiteral) -> (extra:Int, base:Int) 
    {
        self.storage.withUnsafeMutablePointerToElements 
        {
            let raw:UnsafeRawPointer = .init($0)
            let offset:Int          = 256 &+ 
                MemoryLayout<Composite>.stride &* runliteral.decade
            let composite:Composite = raw.load(fromByteOffset: offset, as: Composite.self)
            return (extra: .init(composite.extra), base: .init(composite.base))
        }
    }
    func composite(decade distance:LZ77.Symbol.Distance) -> (extra:Int, base:Int) 
    {
        self.storage.withUnsafeMutablePointerToElements 
        {
            let raw:UnsafeRawPointer = .init($0)
            // should get constant-folded
            let offset:Int          = (256 + 32 * MemoryLayout<Composite>.stride) &+ 
                MemoryLayout<Composite>.stride &* distance.decade
            let composite:Composite = raw.load(fromByteOffset: offset, as: Composite.self)
            return (extra: .init(composite.extra), base: .init(composite.base))
        }
    }
    
    static 
    let fixed:Self = .init(
        runliteral: LZ77.FixedHuffman.runliteral, 
        distance:   LZ77.FixedHuffman.distance)
}
extension LZ77.Inflator.Semistatic 
{
    struct Meta 
    {
        private 
        var storage:ManagedBuffer<Void, UInt8>
    }
}
extension LZ77.Inflator.Semistatic.Meta 
{
    private static 
    var size:Int 
    {
        256 + 256 * MemoryLayout<LZ77.Symbol.Meta>.stride
    }
    
    init()  
    {
        self.storage = .create(minimumCapacity: Self.size){ _ in () }
        self.storage.withUnsafeMutablePointerToElements 
        {
            $0.initialize(from: LZ77.Reversed.table, count: 256)
        }
    }
    
    mutating 
    func exclude() 
    {
        if !isKnownUniquelyReferenced(&self.storage)
        {
            #if WARN_COPY_ON_WRITE
            print("warning: managed buffer in type '\(String.init(reflecting: Self.self))' has multiple references; buffer is being copied to preserve value semantics")
            #endif 
            
            self.storage = self.storage.withUnsafeMutablePointerToElements 
            {
                (body:UnsafeMutablePointer<UInt8>) in 
                
                let new:ManagedBuffer<Void, UInt8> = 
                    .create(minimumCapacity: Self.size){ _ in () }
                new.withUnsafeMutablePointerToElements 
                {
                    $0.initialize(from: body, count: Self.size)
                }
                return new 
            } 
        }
    }
    
    func replace(tree:LZ77.Huffman<UInt8>) 
    {
        assert(tree.size.z <= 256)
        self.storage.withUnsafeMutablePointerToElements 
        {
            // write huffman tables 
            ($0 + 256).withMemoryRebound(to: LZ77.Symbol.Meta.self, capacity: 256)
            {
                tree.table(initializing: $0)
            }
        }
    }
    
    subscript(codeword:UInt8) -> LZ77.Symbol.Meta  
    {
        self.storage.withUnsafeMutablePointerToElements 
        {
            let raw:UnsafeRawPointer    = .init($0)
            let index:Int               = .init($0[.init(codeword)])
            let offset:Int              = 256 &+ 
                MemoryLayout<LZ77.Symbol.Meta>.stride &* index 
            return raw.load(fromByteOffset: offset, as: LZ77.Symbol.Meta.self)
        }
    }
}

// symbol types 
protocol _LZ77SymbolPattern 
{
    associatedtype Symbol 
    init(_ symbol:Symbol, length:Int)
}
extension LZ77 
{    
    enum Symbol 
    {
        typealias Pattern = _LZ77SymbolPattern
        struct Meta:Pattern 
        {
            //  8               0
            //  [c:c:c:s:s:s:s:s]
            //   ~~~~~^~~~~~~~~~^
            //   length    symbol
            private 
            let storage:UInt8 
            
            var symbol:UInt8 
            {
                self.storage & 0b0001_1111
            }
            var length:Int 
            {
                .init(self.storage >> 5)
            }
            
            init(_ symbol:UInt8, length:Int) 
            {
                self.storage = .init(length) << 5 | symbol
            }
        }
        
        struct RunLiteral:Pattern 
        {
            // 16               8               0
            //  [c:c:c:c: : : :s|s:s:s:s:s:s:s:s] 
            //   ~~~~~~~^      ~~~~~~~~~~~~~~~~~^
            //     length                  symbol
            private 
            let storage:UInt16 
            
            var symbol:UInt16 
            {
                self.storage & 0b0000_0001_1111_1111
            }
            var literal:UInt8 
            {
                .init(truncatingIfNeeded: self.storage)
            }
            var decade:Int 
            {
                .init(self.storage & 0b0000_0000_1111_1111)
            }
            var length:Int 
            {
                .init(self.storage >> 12)
            }
            init(_ symbol:UInt16, length:Int) 
            {
                self.storage = .init(length) << 12 | symbol 
            }
        }
        struct Distance:Pattern 
        {
            // 16               8               0
            //  [ : : : :c:c:c:c| : : :s:s:s:s:s] 
            //           ~~~~~~~^      ~~~~~~~~~^
            //             length          symbol
            // length goes here because it is probably slightly faster to 
            // address the high byte than do a UInt16 bit shift
            private 
            let storage:UInt16 
            
            var decade:Int 
            {
                .init(self.storage & 0x00ff)
            }
            var length:Int 
            {
                .init(self.storage >> 8)
            }
            init(_ symbol:UInt8, length:Int) 
            {
                self.storage = .init(length) << 8 | .init(symbol)
            }
        }
    }
}

extension FixedWidthInteger 
{
    // rounds up to the next power of two, with 0 rounding up to 1. 
    // numbers that are already powers of two return themselves
    @inline(__always)
    var nextPowerOfTwo:Self 
    {
        1 &<< (Self.bitWidth &- (self &- 1).leadingZeroBitCount)
    }
}

extension LZ77.Inflator 
{
    struct In 
    {
        private 
        var capacity:Int, // units in atoms
            bytes:Int 
        private 
        var storage:ManagedBuffer<Void, UInt16>
    }
}
extension LZ77.Inflator.In 
{        
    var count:Int 
    {
        self.bytes << 3
    }
    
    // calculates number of atoms given byte count 
    @inline(__always)
    private static 
    func atoms(bytes:Int) -> Int 
    {
        (bytes + 1) >> 1 + 3 // 3 padding shorts
    }
    
    // Bitstreams are indexed from LSB to MSB within each atom 
    //      
    // atom 0   16 [ ← ← ← ← ← ← ← ← ]  0
    // atom 1   32 [ ← ← ← ← ← ← ← ← ] 16
    // atom 2   48 [ ← ← ← ← ← ← ← ← ] 32
    // atom 3   64 [ ← ← ← ← ← ← ← ← ] 48
    init(_ data:[UInt8])
    {
        self.capacity   = 0
        self.bytes      = 0
        self.storage    = .create(minimumCapacity: 0){ _ in () }
        
        var b:Int  = 0
        self.rebase(data, pointer: &b)
    }
    
    // discards all bits before the pointer `b`
    mutating 
    func rebase(_ data:[UInt8], pointer b:inout Int)  
    {
        guard !data.isEmpty 
        else 
        {
            return 
        }
        
        let a:Int = b >> 4 
        // calculate new buffer size 
        let rollover:Int    = self.bytes - 2 * a
        let minimum:Int     = Self.atoms(bytes: rollover + data.count)
        
        #if WARN_COPY_ON_WRITE
        if !isKnownUniquelyReferenced(&self.storage) 
        {
            print("warning: managed buffer in type '\(String.init(reflecting: Self.self))' has multiple references; buffer is being copied to preserve value semantics")
        }
        #endif 
        
        if self.capacity < minimum || !isKnownUniquelyReferenced(&self.storage)
        {
            // reallocate storage 
            var capacity:Int = minimum.nextPowerOfTwo
            let new:ManagedBuffer<Void, UInt16> = .create(minimumCapacity: capacity) 
            {
                capacity    = $0.capacity
                return ()
            }
            // transfer leftover elements 
            self.capacity   = capacity
            self.storage    = self.storage.withUnsafeMutablePointerToElements 
            {
                (old:UnsafeMutablePointer<UInt16>) in
                new.withUnsafeMutablePointerToElements 
                {
                    $0.assign(from: old + a, count: (rollover + 1) >> 1)
                }
                return new
            }
        }
        else if a > 0
        {
            // shift to beginning 
            self.storage.withUnsafeMutablePointerToElements 
            {
                $0.assign(from: $0 + a, count: (rollover + 1) >> 1)
            }
        }
        
        b         -= a << 4
        // write new data 
        data.withUnsafeBufferPointer
        {
            (data:UnsafeBufferPointer<UInt8>) in 
            self.storage.withUnsafeMutablePointerToElements 
            {
                // already checked !data.isEmpty
                let count:Int
                var start:UnsafePointer<UInt8>  = data.baseAddress!
                let i:Int                       = (rollover + 1) >> 1
                if rollover & 1 != 0 
                {
                    // odd number of bytes in the stream: move over 1 byte from the new data
                    $0[i - 1]  &= 0x00ff
                    $0[i - 1]  |= .init(start.pointee) << 8 
                    start      += 1
                    count       = data.count - 1
                }
                else 
                {
                    count       = data.count 
                }
                
                for j:Int in 0 ..< count >> 1 
                {
                    $0[i &+          j]   = .init(start[j << 1 | 1]) << 8 | 
                                            .init(start[j << 1    ])
                }
                let k:Int = i + (count + 1) >> 1
                if count & 1 != 0
                {
                    $0[k &-         1]    = .init(start[count  - 1])
                }
                // write 48 bits of padding 
                $0[k    ] = 0x0000
                $0[k + 1] = 0x0000
                $0[k + 2] = 0x0000
            }
            
            self.bytes = rollover + data.count
        }
    }
    
    // puts bits in low end of outputted integer 
    // 
    //  { b.15, b.14, b.13, b.12, b.11, b.10, b.9, b.8, b.7, b.6, b.5, b.4, b.3, b.2, b.1, b.0 }
    //                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //                                                                   ^  
    //                                       [4, count: 6, as: UInt16.self]
    //      produces 
    //  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, b.10, b.9, b.8, b.7, b.6, b.5, b.4}
    subscript<I>(i:Int, count count:Int, as _:I.Type) -> I 
        where I:FixedWidthInteger
    {
        self.storage.withUnsafeMutablePointerToElements 
        {
            guard count > 0 
            else 
            {
                return .zero 
            }
            
            let a:Int = i >> 4, 
                b:Int = i & 0x0f
            //    a + 2           a + 1             a
            //      [ : : :x:x:x:x:x|x:x: : : : : : ]
            //             ~~~~~~~~~~~~~^
            //            count = 14, b = 12
            //
            //      →               [ :x:x:x:x:x|x:x]
            let extended:UInt32 = .init($0[a &+ 1]) << 16 | .init($0[a]),
                mask:UInt32     = ~(UInt32.max &<< count)
            return .init(extended &>> b & mask)
        }
    }
    subscript(i:Int) -> UInt16 
    {
        self.storage.withUnsafeMutablePointerToElements 
        {
            let a:Int = i >> 4,
                b:Int = i & 0x0f
            //    a + 2           a + 1             a
            //      [ : :x:x:x:x:x:x|x:x: : : : : : ]
            //           ~~~~~~~~~~~~~~~^
            //            count = 16, b = 12
            //
            //      →   [x:x:x:x:x:x|x:x]
            //  creating a uint32 and shifting that is faster than shifting
            //  the two components individually
            let extended:UInt32 = .init($0[a &+ 1]) << 16 | .init($0[a])
            return .init(truncatingIfNeeded: extended &>> b)
        }
    }
}
extension LZ77.Inflator.In:ExpressibleByArrayLiteral 
{
    init(arrayLiteral:UInt8...) 
    {
        self.init(arrayLiteral)
    }
}
extension LZ77.Inflator 
{
    struct Out 
    {
        var window:Int
         
        private(set)
        var startIndex:Int,
            currentIndex:Int,
            endIndex:Int 
        // storing this instead of using `ManagedBuffer.capacity` because 
        // the apple docs said so
        private 
        var capacity:Int
        
        private 
        var storage:ManagedBuffer<Void, UInt8>
        
        private
        var integral:(single:UInt32, double:UInt32)
    }
}
extension LZ77.Inflator.Out 
{
    init() 
    {
        var capacity:Int    = 0
        self.storage = .create(minimumCapacity: 0)
        {
            capacity = $0.capacity 
            return ()
        }
        self.window         = 0
        self.startIndex     = 0
        self.currentIndex   = 0
        self.endIndex       = 0
        self.capacity       = capacity
        
        self.integral       = (1, 0)
    }
    
    mutating 
    func exclude() 
    {
        if !isKnownUniquelyReferenced(&self.storage)
        {
            #if WARN_COPY_ON_WRITE
            print("warning: managed buffer in type '\(String.init(reflecting: Self.self))' has multiple references; buffer is being copied to preserve value semantics")
            #endif 
            
            self.storage = self.storage.withUnsafeMutablePointerToElements 
            {
                (body:UnsafeMutablePointer<UInt8>) in 
                
                let new:ManagedBuffer<Void, UInt8> = 
                    .create(minimumCapacity: self.capacity)
                {
                    self.capacity = $0.capacity
                    return ()
                }
                new.withUnsafeMutablePointerToElements 
                {
                    // cannot do shift here, since the checksum has to be updated
                    $0.assign(from: body, count: self.endIndex)
                }
                return new 
            } 
        }
    }
    
    mutating 
    func release(bytes count:Int) -> [UInt8]? 
    {
        self.storage.withUnsafeMutablePointerToElements  
        {
            guard self.endIndex >= self.currentIndex + count 
            else 
            {
                return nil 
            }
            
            let slice:UnsafeBufferPointer<UInt8> =
                .init(start: $0 + self.currentIndex, count: count)
            defer 
            {
                let limit:Int       = Swift.max(self.endIndex - self.window, self.startIndex)
                self.currentIndex  += count 
                self.startIndex     = Swift.min(self.currentIndex, limit)
            }
            return .init(slice)
        }
    }
    
    // releases everything 
    mutating 
    func release() -> [UInt8] 
    {
        self.storage.withUnsafeMutablePointerToElements  
        {
            let count:Int = self.endIndex - self.currentIndex
            let slice:UnsafeBufferPointer<UInt8>
                = .init(start: $0 + self.currentIndex, count: count)
            defer 
            {
                self.currentIndex   =           self.endIndex
                self.startIndex     = Swift.max(self.endIndex - self.window, self.startIndex)
            }
            return .init(slice)
        }
    }

    mutating 
    func append(_ value:UInt8) 
    {
        self.reserve(1)
        self.storage.withUnsafeMutablePointerToElements 
        {
            $0[self.endIndex] = value
        }
        self.endIndex &+= 1
    }
    mutating 
    func expand(offset:Int, count:Int) 
    {
        self.reserve(count)
        self.storage.withUnsafeMutablePointerToElements 
        {
            let start:UnsafeMutablePointer<UInt8>   = $0 + self.endIndex
            // cannot use assign(from:count:) because the standard library implementation
            // copies from the back to the front if the ranges overlap
            // https://github.com/apple/swift/blob/master/stdlib/public/core/UnsafePointer.swift#L745
            for current:UnsafeMutablePointer<UInt8> in start ..< start + count
            {
                current.pointee = (current - offset).pointee
            }
        }
        self.endIndex &+= count
    }
    
    @inline(__always)
    private mutating 
    func reserve(_ count:Int) 
    {
        if self.capacity < self.endIndex &+ count
        {
            self.shift(allocating: count)
        }
    }
    // may discard array elements before `startIndex`, adjusts capacity so that 
    // at least one more byte can always be written without a reallocation
    private mutating 
    func shift(allocating extra:Int) 
    {
        // optimal new capacity
        let count:Int       = self.endIndex - self.startIndex, 
            capacity:Int    = (count + Swift.max(16, extra)).nextPowerOfTwo
        if self.capacity >= capacity 
        {
            // rebase without reallocating 
            self.storage.withUnsafeMutablePointerToElements 
            {
                self.integral   = LZ77.MRC32.update(self.integral, 
                            from: $0,                   count: self.startIndex)
                $0.assign(  from: $0 + self.startIndex, count: count)
                self.currentIndex  -= self.startIndex
                self.endIndex      -= self.startIndex
                self.startIndex     = 0
            }
        }
        else 
        {
            self.storage = self.storage.withUnsafeMutablePointerToElements 
            {
                (body:UnsafeMutablePointer<UInt8>) in 
                
                let new:ManagedBuffer<Void, UInt8> = .create(minimumCapacity: capacity)
                {
                    self.capacity = $0.capacity
                    return ()
                }
                
                new.withUnsafeMutablePointerToElements 
                {
                    self.integral   = LZ77.MRC32.update(self.integral,
                                from: body,                   count: self.startIndex)
                    $0.assign(  from: body + self.startIndex, count: count)
                }
                self.currentIndex  -= self.startIndex
                self.endIndex      -= self.startIndex
                self.startIndex     = 0
                return new 
            }
        }
    }

    mutating 
    func checksum() -> UInt32 
    {
        // everything still in the storage buffer has not yet been integrated 
        self.storage.withUnsafeMutablePointerToElements 
        {
            let (single, double):(UInt32, UInt32) = 
                LZ77.MRC32.update(self.integral, from: $0, count: self.endIndex)
            return double << 16 | single
        }
    }
}

extension LZ77 
{ 
    struct Inflator 
    {
        private 
        enum State 
        {
            case streamStart 
            case blockStart
            case blockTables(final:Bool, runliterals:Int, distances:Int)
            case blockUncompressed(final:Bool, end:Int)
            case blockCompressed(final:Bool, semistatic:Semistatic)
            case streamChecksum
            case streamEnd 
        }
        struct Stream 
        {
            enum Compression  
            {
                case none(bytes:Int)
                case fixed 
                case dynamic(runliterals:Int, distances:Int)
            }
            
            let format:Format 
            // Stream.In manages its own COW in rebase(_:pointer:)
            var input:In,
                b:Int 
            var lengths:[Int]
            // Meta and Stream.Out need to have COW manually implemented with 
            // exclude() on each, to avoid redundant exclusions inside loops,,
            // reuse the same buffer since the size is fixed
            var meta:Semistatic.Meta 
            var output:Out
            
            #if DUMP_LZ77_BLOCKS || DUMP_LZ77_SYMBOL_HISTOGRAM
            // histogram, no match can ever cost more than 17 bits per literal
            var statistics: 
            (
                literals:[Int],
                matches:[Int], 
                symbols:[Int]
            ) 
            = 
            (
                literals:   .init(repeating: 0, count: 16), 
                matches:    .init(repeating: 0, count: 17), 
                // 2d symbol histogram (run, distance) 
                symbols:    .init(repeating: 0, count: 29 * 30)
            )
            #endif
            
            init(format:Format) 
            {
                self.format     = format 
                
                self.b          = 0
                self.input      = []
                self.lengths    = []
                self.meta       = .init()
                self.output     = .init()
            }
        }
        
        private 
        var state:State, 
            stream:Stream 
    }
}
extension LZ77.Inflator 
{
    init(format:LZ77.Format = .zlib) 
    {
        self.state  = .streamStart
        self.stream = .init(format: format)
    }
    
    // returns `nil` if the stream is finished
    mutating 
    func push(_ data:[UInt8]) throws -> Void?
    {
        self.stream.input.rebase(data, pointer: &self.stream.b)
        while let _:Void = try self.advance() 
        {
        }
        if case .streamEnd = self.state 
        {
            return nil 
        }
        else 
        {
            return ()
        }
    }
    mutating 
    func pull(_ count:Int) -> [UInt8]? 
    {
        self.stream.output.exclude()
        return self.stream.output.release(bytes: count)
    }
    mutating 
    func pull() -> [UInt8]
    {
        self.stream.output.exclude()
        return self.stream.output.release()
    }
    
    // returns nil if unable to advance 
    private mutating 
    func advance() throws -> Void?
    {
        // pool cow-exclusions here instead of checking the reference count 
        // on every loop iteration
        self.stream.meta.exclude()
        self.stream.output.exclude()
        switch self.state 
        {
        case .streamStart:
            guard let window:Int = try self.stream.start()
            else 
            {
                return nil
            }
            self.stream.output.window   = window 
            self.state                  = .blockStart
        
        case .blockStart:
            guard let (final, compression):(Bool, Stream.Compression) = 
                try self.stream.blockStart() 
            else 
            {
                return nil 
            }
            
            switch compression 
            {
            case .dynamic(runliterals: let runliterals, distances: let distances):
                self.state = .blockTables(final: final, 
                    runliterals: runliterals, distances: distances)
            
            case .fixed:
                self.state = .blockCompressed(final: final, semistatic: .fixed)
            
            case .none(bytes: let count):
                // compute endindex 
                let end:Int = self.stream.output.endIndex + count
                self.state = .blockUncompressed(final: final, end: end)
            }
            
            #if DUMP_LZ77_BLOCKS 
            print("< \(compression)")
            #endif 
        
        case .blockTables(final: let final, runliterals: let runliterals, distances: let distances):
            guard let (runliteral, distance):(LZ77.Huffman<UInt16>, LZ77.Huffman<UInt8>) = 
                try self.stream.blockTables(runliterals: runliterals, distances: distances) 
            else 
            {
                return nil
            }
            
            self.state = .blockCompressed(final: final,
                semistatic: .init(runliteral: runliteral, distance: distance))
        
        case .blockUncompressed(final: let final, end: let end):
            guard let _:Void = try self.stream.blockUncompressed(end: end) 
            else 
            {
                return nil
            }
            self.state = final ? .streamChecksum : .blockStart
        
        case .blockCompressed(final: let final, semistatic: let semistatic):
            guard let _:Void = try self.stream.blockCompressed(semistatic: semistatic) 
            else 
            {
                return nil
            }
            self.state = final ? .streamChecksum : .blockStart
        
        case .streamChecksum:
            guard let _:Void = try self.stream.checksum()
            else 
            {
                return nil 
            }
            self.state = .streamEnd 
        case .streamEnd:
            return nil 
        }
        
        return ()
    }
}
extension LZ77.Inflator.Stream 
{
    mutating 
    func start() throws -> Int?
    {
        if case .ios = self.format 
        {
            return 1 << 15
        }
        
        // read stream header 
        guard self.b + 16 <= self.input.count 
        else 
        {
            return nil 
        }
        
        switch self.input[self.b + 0, count: 4, as: UInt8.self]  
        {
        case 8:
            break 
        case let code:
            throw LZ77.DecompressionError.invalidStreamCompressionMethodCode(code)
        }
        
        let exponent:Int = self.input[self.b + 4, count: 4, as: Int.self] 
        guard exponent < 8 
        else 
        {
            throw LZ77.DecompressionError.invalidStreamWindowSize(exponent: exponent + 8)
        }
        
        let flags:Int = self.input[self.b + 8, count: 8, as: Int.self]
        guard (exponent << 12 | 8 << 8 + flags) % 31 == 0 
        else 
        {
            throw LZ77.DecompressionError.invalidStreamHeaderCheckBits
        }
        guard flags & 0x20 == 0 
        else 
        {
            throw LZ77.DecompressionError.unexpectedStreamDictionary
        }
        
        self.b += 16
        return 1 << (8 + exponent)
    }
    mutating 
    func blockStart() throws -> 
    (
        final:Bool, 
        compression:Compression
    )? 
    {
        guard self.b + 3 <= self.input.count 
        else 
        {
            return nil 
        }
        
        // read block header bits 
        let final:Bool = self.input[self.b, count: 1, as: UInt8.self] != 0 
        let compression:Compression 
        switch self.input[self.b + 1, count: 2, as: UInt8.self] 
        {
        case 0:
            // skip to next byte boundary, read 4 bytes 
            let boundary:Int = (self.b + 3 + 7) & ~7
            guard boundary + 32 <= self.input.count 
            else 
            {
                return nil 
            }
            
            let l:UInt16 = self.input[boundary,      count: 16, as: UInt16.self],
                m:UInt16 = self.input[boundary + 16, count: 16, as: UInt16.self]
            guard l == ~m 
            else 
            {
                throw LZ77.DecompressionError.invalidBlockElementCountParity(l, m)
            }
            
            compression = .none(bytes: .init(l))
            self.b  = boundary + 32
        
        case 1:
            compression = .fixed 
            self.b += 3
        
        case 2:
            guard self.b + 17 <= self.input.count 
            else 
            {
                return nil 
            }
        
            let codelengths:Int =   4 + self.input[self.b + 13, count: 4, as: Int.self]
            
            guard self.b + 17 + 3 * codelengths <= self.input.count 
            else 
            {
                return nil 
            }
            
            let runliterals:Int = 257 + self.input[self.b +  3, count: 5, as: Int.self]
            let distances:Int   =   1 + self.input[self.b +  8, count: 5, as: Int.self]
            // other counts don’t need to be checked because the number of bits 
            // matches the acceptable range 
            guard 257 ... 286 ~= runliterals
            else 
            {
                throw LZ77.DecompressionError.invalidHuffmanRunLiteralSymbolCount(runliterals)
            }
            
            var lengths:[Int] = .init(repeating: 0, count: 19)
            for (i, d):(Int, Int) in
                zip(0 ..< codelengths, [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
            {
                lengths[d] = self.input[self.b + 17 + 3 * i, count: 3, as: Int.self]
            }
            guard let tree:LZ77.Huffman<UInt8> = .validate(symbols: 0 ... 18, lengths: lengths)
            else 
            {
                throw LZ77.DecompressionError.invalidHuffmanCodelengthHuffmanTable 
            }
            
            self.meta.replace(tree: tree)
            
            self.b += 17 + 3 * codelengths
            compression = .dynamic(runliterals: runliterals, distances: distances)
        
        case let code:
            throw LZ77.DecompressionError.invalidBlockTypeCode(code)
        }
        
        return (final, compression)
    }
    mutating 
    func blockTables(runliterals:Int, distances:Int)
        throws -> (runliteral:LZ77.Huffman<UInt16>, distance:LZ77.Huffman<UInt8>)?
    {
        // code lengths form an unbroken sequence 
        codelengths:
        while self.lengths.count < runliterals + distances 
        {
            guard self.b < self.input.count 
            else 
            {
                return nil 
            }
            
            let meta:LZ77.Symbol.Meta = 
                self.meta[.init(truncatingIfNeeded: self.input[self.b])]
            // if the codeword length is longer than the available input 
            // then we know the match is invalid (due to padding 0-bits)
            guard self.b + meta.length <= self.input.count 
            else 
            {
                return nil 
            }
            
            //  from the RFC 1951: 
            //  0 - 15: Represent code lengths of 0 - 15
            //      16: Copy the previous code length 3 - 6 times.
            //          The next 2 bits indicate repeat length
            //                (0 = 3, ... , 3 = 6)
            //             Example:  Codes 8, 16 (+2 bits 11),
            //                       16 (+2 bits 10) will expand to
            //                       12 code lengths of 8 (1 + 6 + 5)
            //      17: Repeat a code length of 0 for 3 - 10 times.
            //          (3 bits of length)
            //      18: Repeat a code length of 0 for 11 - 138 times
            //          (7 bits of length)
            let element:Int, 
                extra:Int, 
                base:Int
            switch meta.symbol 
            {
            case 0 ..< 16:
                self.lengths.append(.init(meta.symbol))
                self.b += meta.length
                continue codelengths
            
            case 16:
                guard let last:Int = self.lengths.last 
                else 
                {
                    throw LZ77.DecompressionError.invalidHuffmanCodelengthSequence
                }
                element = last 
                extra   = 2
                base    = 3
            
            case 17:
                element = 0 
                extra   = 3
                base    = 3
            
            case 18:
                element = 0 
                extra   = 7
                base    = 11
            
            default:
                fatalError("unreachable")
            } 
            
            guard self.b + meta.length + extra <= self.input.count 
            else 
            {
                return nil 
            }
            let repetitions:Int = base + 
                self.input[self.b + meta.length, count: extra, as: Int.self]
            
            self.lengths.append(contentsOf: repeatElement(element, count: repetitions))
            self.b += meta.length + extra 
        }
        defer 
        {
            // important
            self.lengths.removeAll(keepingCapacity: true)
        }
        guard self.lengths.count == runliterals + distances 
        else 
        {
            throw LZ77.DecompressionError.invalidHuffmanCodelengthSequence
        }
        
        #if DUMP_LZ77_TERMS 
        print("< dynamic run-literal codelengths:")
        for (i, length):(Int, Int) in self.lengths.prefix(runliterals).enumerated() 
            where length > 0
        {
            print("    [\(String.pad("\(i)", left: 3))]: \(length)")
        }
        print("< dynamic distance codelengths:")
        for (i, length):(Int, Int) in self.lengths.dropFirst(runliterals).enumerated() 
            where length > 0
        {
            print("    [\(String.pad("\(i)", left: 3))]: \(length)")
        }
        #endif 
        
        guard   let runliteral:LZ77.Huffman<UInt16> = .validate(
                    symbols:        0 ... 287,
                    lengths:        self.lengths.prefix(runliterals)),
                let distance:LZ77.Huffman<UInt8> = .validate(
                    symbols:        0 ... 31,
                    normalizing:    self.lengths.dropFirst(runliterals))
        else 
        {
            throw LZ77.DecompressionError.invalidHuffmanTable 
        }
        return (runliteral, distance)
    }
    mutating 
    func blockCompressed(semistatic:LZ77.Inflator.Semistatic) throws -> Void? 
    {
        while self.b < self.input.count 
        {
            //  one token (either a literal, or a length-distance pair with extra bits)
            //  never requires more than 48 bits of input:
            //  
            //  first codeword  : 15 bits 
            //  first extras    :  5 bits 
            //  second codeword : 15 bits 
            //  second extras   : 13 bits 
            //  -------------------------
            //  total           : 48 bits 
            let first:UInt16 = self.input[self.b]
            let runliteral:LZ77.Symbol.RunLiteral = 
                semistatic[first, as: LZ77.Symbol.RunLiteral.self]
            
            if      runliteral.symbol <  256 
            {
                guard self.b + runliteral.length <= self.input.count 
                else 
                {
                    return nil 
                }
                self.b += runliteral.length 
                self.output.append(runliteral.literal)
                
                #if DUMP_LZ77_TERMS 
                print("< literal(\(runliteral.literal))")
                #endif 
                #if DUMP_LZ77_BLOCKS || DUMP_LZ77_SYMBOL_HISTOGRAM
                self.statistics.literals[runliteral.length] += 1
                #endif
            }
            else if runliteral.symbol == 256 
            {
                guard self.b + runliteral.length <= self.input.count 
                else 
                {
                    return nil 
                }
                self.b += runliteral.length 
                
                #if DUMP_LZ77_TERMS 
                print("< end-of-block\n")
                #endif 
                #if DUMP_LZ77_BLOCKS || DUMP_LZ77_SYMBOL_HISTOGRAM
                self.statistics.literals[runliteral.length] += 1
                #endif
                
                return () 
            }
            else 
            {
                // get the next two words to form a 48-bit value 
                // (in the low bits bits of a UInt64)
                // we put it in the low bits so that we can do masking shifts instead 
                // of checked shifts 
                var slug:UInt64 = 
                    .init(self.input[self.b + 32]) << 32 |
                    .init(self.input[self.b + 16]) << 16 | 
                    .init(first)
                slug &>>= runliteral.length
                
                let composite:
                (
                    count:(extra:Int, base:Int),
                    offset:(extra:Int, base:Int)
                )
                
                composite.count     = semistatic.composite(decade: runliteral) 
                let count:Int       = composite.count.base &+ 
                    .init(truncatingIfNeeded: slug & ~(.max &<< composite.count.extra))
                
                slug &>>= composite.count.extra
                
                let distance:LZ77.Symbol.Distance = 
                    semistatic[.init(truncatingIfNeeded: slug), as: LZ77.Symbol.Distance.self]
                slug &>>= distance.length
                
                composite.offset    = semistatic.composite(decade: distance) 
                let offset:Int      = composite.offset.base &+ 
                    .init(truncatingIfNeeded: slug & ~(.max &<< composite.offset.extra))
                
                let b:Int = self.b      + 
                    runliteral.length   + composite.count.extra + 
                    distance.length     + composite.offset.extra 
                guard b <= self.input.count 
                else 
                {
                    return nil 
                }
                
                guard self.output.endIndex - offset >= self.output.startIndex 
                else 
                {
                    throw LZ77.DecompressionError.invalidStringReference
                }
                
                #if DUMP_LZ77_TERMS 
                print("< match(offset: \(-offset), run: \(count))")
                #endif 
                #if DUMP_LZ77_BLOCKS || DUMP_LZ77_SYMBOL_HISTOGRAM
                let n:Int = 29 * .init(distance.decade) + .init(runliteral.symbol - 257)
                let m:Int = 
                    runliteral.length + composite.count.extra + 
                    distance.length   + composite.offset.extra
                self.statistics.symbols[n]          += 1
                self.statistics.matches[m / count]  += 1
                #endif
                
                self.output.expand(offset: offset, count: count)
                self.b = b
            }
        }
        return nil
    }
    mutating 
    func blockUncompressed(end:Int) throws -> Void? 
    {
        while self.output.endIndex < end
        {
            guard self.b + 8 <= self.input.count 
            else 
            {
                return nil 
            }
            self.output.append(self.input[self.b, count: 8, as: UInt8.self])
            self.b += 8
        }
        
        return ()
    }
    mutating 
    func checksum() throws -> Void?
    {
        #if DUMP_LZ77_BLOCKS 
        let efficiency:Double = self.statistics.literals.enumerated().reduce(0.0){ $0 + .init($1.0 * $1.1) } / 
            .init(self.statistics.literals.reduce(0, +))
        print("< average literal coding efficiency: \(efficiency)")
        print("< match coding efficiency histogram:")
        for (bin, frequency):(Int, Int) in self.statistics.matches.enumerated()
        {
            print("    [\(bin) ..< \(bin + 1) bits]: \(frequency)")
        }
        print("< run-distance symbol histogram:")
        #endif
        #if DUMP_LZ77_BLOCKS || DUMP_LZ77_SYMBOL_HISTOGRAM
        print(String.init(histogram: self.statistics.symbols, size: (29, 30), pad: 4))
        #endif 
        
        if case .ios = self.format 
        {
            return ()
        }
        
        // skip to next byte boundary, read 4 bytes 
        let boundary:Int = (self.b + 7) & ~7
        guard boundary + 32 <= self.input.count 
        else 
        {
            return nil 
        }
        
        // mrc-32 is big-endian 
        let bytes:(UInt32, UInt32, UInt32, UInt32) = 
        (
            self.input[boundary,      count: 8, as: UInt32.self],
            self.input[boundary +  8, count: 8, as: UInt32.self],
            self.input[boundary + 16, count: 8, as: UInt32.self],
            self.input[boundary + 24, count: 8, as: UInt32.self]
        )
        let checksum:UInt32   = bytes.0 << 24 |
                                bytes.1 << 16 |
                                bytes.2 <<  8 |
                                bytes.3
        let computed:UInt32   = self.output.checksum()
        guard computed == checksum
        else 
        {
            throw LZ77.DecompressionError.invalidStreamChecksum(
                declared: checksum, computed: computed)
        } 
        self.b = boundary + 32
        return ()
    }
}
